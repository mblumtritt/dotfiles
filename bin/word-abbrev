#!/usr/bin/env ruby --disable-all
# frozen_string_literal: true

out("#{me} v0.1.0") if %w[-v --version].include?(ARGV[0])
out(<<~HELP) if %w[-h --help].include?(ARGV[0])
  Usage: #{me}
    Read wordlist from $stdin and print all words and abbreviations.

  Usage: #{me} -a|--abbrev
    Read wordlist from $stdin and print all abbreviations only.

  Usage: #{me} <word>
    Read wordlist from $stdin and print matching word.
    Eixts with errorcode 1 when no matching word was found.

  Usage: #{me} -v|--version
    Print version information.

  Usage: #{me} -h|--help
    Print this help information.
HELP

BEGIN {
  def me = File.basename(Process.argv0)
  def out(msg) = (puts(msg) or exit)
}

def die!(msg) = ($stderr.puts("#{me}: #{msg}") or exit(1))
die!('too many arguments') if ARGV.size > 1

ABBREV_ONLY = %w[-a --abbrev].include?(ARGV[0])
FIND_WORD = (ABBREV_ONLY ? nil : ARGV[0])
Word = Struct.new(:value, :word_count, :sub)

def read_in
  word_pad = Set.new
  tabu = Set.new
  ret = []

  $stdin.each_line(chomp: true) do |line|
    line
      .split
      .map!(&:strip)
      .each do |word|
        next if word.empty?
        out(word) if word == FIND_WORD
        next if word_pad.include?(word)
        word_pad << word
        sub = word.split('-')
        next tabu << word if (sub.size == 1) && (word.size <= 4)
        ret << Word.new(word, sub.size, sub)
      end
  end
  [
    tabu.freeze,
    ret
      .sort! do |a, b|
        r = a.word_count <=> b.word_count
        r == 0 ? a.value <=> b.value : r
      end
      .freeze
  ]
end

def create_abbrevs(words)
  ret = {}
  words.each do |word|
    word.sub.each { |sw| ret[sw] ||= Array.new(sw.size) { |i| sw[..i] } }
  end
  ret.freeze
end

def combine(left, right)
  ret = []
  left.each { |lp| right.each { |rp| ret << "#{lp}#{rp}" } }
  ret
end

def create_candidates(words)
  abbrevs = create_abbrevs(words)
  ret = Hash.new { |h, k| h[k] = [] }
  words.each do |word|
    sub = abbrevs[word.sub.shift]
    sub = combine(sub, abbrevs[word.sub.shift]) until word.sub.empty?
    word.sub = sub.size
    sub.each { |w| ret[w] << word }
  end
  ret
end

def create_result(words, tabu)
  ret = {}.compare_by_identity
  sort_proc =
    proc do |a, b|
      c = b.word_count <=> a.word_count
      next c if ret != 0
      c = a.sub <=> b.sub
      c == 0 ? a.value <=> b.value : c
    end
  create_candidates(words)
    .except(*tabu.to_a)
    .each_pair do |abbrev, ary|
      ary.sort!(&sort_proc)
      best = ary[0]
      ret[best] = abbrev unless ret.key?(best)
    end
  ret.invert
end

tabu, all_words = read_in
all_words = create_result(all_words, tabu)

ABBREV_ONLY and out(all_words.keys)
FIND_WORD and out((all_words[FIND_WORD] || exit(1)).value)

puts(tabu.to_a.sort!)
all_words.keys.sort!.each { |abbrev| puts(abbrev, all_words[abbrev].value) }
