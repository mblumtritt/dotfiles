#! /usr/bin/env ruby
# frozen_string_literal: true

module CLI
  def self.help
    puts <<~USAGE
      Usage: #{my_name} COMMAND [OPTIONS]

      Build-in commands:
        -h, --help    show COMMAND specific help or this screen
        -w, --which   show file name for given COMMAND

      Commands found:
    USAGE
    display_cols(CommandFinder.all)
    exit
  end

  def self.my_name
    File.basename(__FILE__)
  end

  def self.help?(str)
    str == 'help' || str == 'h' || str == '-h' || str == '--help'
  end

  def self.which?(str)
    str == 'which' || str == 'w' || str == '-w' || str == '--which'
  end

  def self.error(msg, subject)
    STDERR.puts("#{my_name}: #{msg} - #{subject}")
    block_given? and yield
    exit(127)
  end

  def self.non_bijective_command(cmd, alternatives, out)
    error('command non-bijective', cmd) do
      out.puts('Did you mean:')
      alternatives.each { |cmd| out.puts('  ' + File.basename(cmd)) }
    end
  end

  def self.find_command(str, out = $stdout)
    found = CommandFinder.find(str) or error('command not found', str)
    non_bijective_command(str, found, out) if Array === found
    found
  end

  def self.which(str)
    puts(find_command(str, $stderr))
    exit
  end

  private_class_method def self.display_cols(ary)
    return ary.each { |str| puts("   #{str}") } unless STDOUT.tty?
    require 'io/console'
    width = ary.max_by(&:size).size + 3
    slice = STDOUT.winsize.last / width
    ary
      .map! { |str| str.ljust(width) }
      .each_slice(slice) { |line| puts(line.join) }
  end
end

CommandFinder =
  Class.new do
    def initialize(dir)
      @dir = File.expand_path(dir)
    end

    def all
      Dir.glob(File.join(@dir, '*')).keep_if do |filename|
        executable?(filename)
      end.map! { |filename| File.basename(filename) }.sort!
    end

    def find(str)
      filename = File.join(@dir, str)
      return filename if executable?(filename)
      commands = []
      each_glob(str) do |glob, size|
        guess = guess(glob, size)
        return guess.first if guess.size == 1
        commands += guess unless guess.empty?
      end
      return if commands.empty?
      commands.uniq!
      commands.sort!
    end

    private

    def guess(glob, size)
      Dir.glob(glob).delete_if do |name|
        name.count('-') > size || !executable?(name)
      end
    end

    def each_glob(str)
      Abbr.weighted_matrix(str).tap(&:pop).each do |ary|
        yield(File.join(@dir, ary.map { |s| s + '*' }.join('-')), ary.size - 1)
      end
    end

    def executable?(filename)
      File.executable_real?(filename)
    end
  end.new('~/bin')

command = ARGV.shift
CLI.help if command.nil? || (ARGV.empty? && CLI.help?(command))

module Abbr
  def self.weighted_matrix(str)
    matrix(str).sort do |a, b|
      next b.map(&:size) <=> a.map(&:size) if a.size == b.size
      ret = b.max_by(&:size).size <=> a.max_by(&:size).size
      ret.zero? ? a.size <=> b.size : ret
    end
  end

  private_class_method def self.matrix(str, ic = false)
    return to_enum(__method__, str.dup) unless block_given?
    return if str.empty?
    yield([str])
    return if str.size == 1
    1.upto(str.size - 1) do |i|
      left = str[0, i]
      right = str[i, str.size - i]
      matrix(right, true) { |ary| yield(ary.unshift(left)) }
    end
    yield(str.chars) unless ic
  end
end

if ARGV.size == 1
  CLI.which(ARGV[0]) if CLI.which?(command)
  exec(CLI.find_command(ARGV[0]), '--help') if CLI.help?(command)
end
exec(CLI.find_command(command), *ARGV)
