#! /usr/bin/env ruby
# frozen_string_literal: true

BIN_DIR = File.expand_path('~/bin')

def valid_command?(fname)
  File.file?(fname) && File.executable_real?(fname)
end

def all_commands
  Dir
    .glob(File.join(BIN_DIR, '*'))
    .keep_if{ |cmd| valid_command?(cmd) }
    .map!{ |cmd| File.basename(cmd) }
    .sort!
end

def my_name
  File.basename(__FILE__)
end

def columns_print(ary)
  require 'io/console'
  width = ary.max_by(&:size).size + 3
  ary
    .map{ |str| str.ljust(width) }
    .each_slice(STDOUT.winsize.last / width){ |line| puts(line.join) }
end

def help
  puts <<~USAGE
    Usage: #{my_name} COMMAND [OPTIONS]

    Build-in commands:
      -h, --help    show COMMAND specific help or this screen
      -w, --which   show file name for given COMMAND

    Commands found:
  USAGE
  columns_print(all_commands)
  exit
end

def help?(str)
  str == 'help' || str == 'h' || str == '-h' || str == '--help'
end

def which?(str)
  str == 'which' || str == 'w' || str == '-w' || str == '--which'
end

command = ARGV.shift
help if command.nil? || (ARGV.empty? && help?(command))

def matrix_for(str)
  [
    [str[0, 4]],
    [str[0, 3], str[3]],
    [str[0], str[1, 3]],
    [str[0, 2], str[2, 2]],
    [str[0, 2], str[2], str[3]],
    [str[0], str[1, 2], str[3]],
    [str[0], str[1], str[2], str[3]],
    [str[0], str[1], str[2, 2]]
  ].each do |ary|
    ary.delete_if{ |e| e.nil? || e.empty? }
  end.uniq
end

def best_matching_command(str)
  guess = File.join(BIN_DIR, str)
  return guess if valid_command?(guess)
  maybe = []
  matrix_for(str).each do |ary|
    guess = Dir.glob(File.join(BIN_DIR, ary.join('*-') + '*'))
    guess.delete_if{ |s| s.count('-') > ary.size || !valid_command?(s) }
    next if guess.empty?
    return guess[0] if guess.size == 1
    maybe += guess
  end
  maybe.uniq!
  return nil if maybe.empty?
  1.upto(3) do |i|
    shortest = maybe.select{ |name| File.basename(name).count('-') == i }
    return shortest[0] if shortest.size == 1
  end
  maybe.sort!
end

def error(msg, subject)
  $stderr.puts("#{my_name}: #{msg} - #{subject}")
  block_given? and yield
  exit(127)
end

def non_bijective_command(cmd, alternatives, out)
  error('command non-bijective', cmd) do
    out.puts('Did you mean:')
    alternatives.each{ |cmd| out.puts('  ' + File.basename(cmd)) }
  end
end

def find_command(str, out = $stdout)
  found = best_matching_command(str) or error('command not found', str)
  non_bijective_command(str, found, out) if Array === found
  found
end

def which(str)
  puts(find_command(str, $stderr))
  exit
end

if ARGV.size == 1
  which(ARGV[0]) if which?(command)
  exec(find_command(ARGV[0]), '--help') if help?(command)
end

exec(find_command(command), *ARGV)
