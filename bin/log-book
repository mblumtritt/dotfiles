#!/usr/bin/env ruby --disable-all
# frozen_string_literal: true

VERSION = '0.2.1'
NAME = File.basename(Process.argv0).freeze
def pex(msg, out: $stdout, code: 0) = (out.puts(msg) or exit(code))
trap(2) { exit(138) }

pex(<<~HELP) if %w[-h --help help].include?(ARGV[0])
  #{NAME} [-t|--topic <topic>] [<message>]
    Log a <message> or all stdin lines to a given <topic>.

  #{NAME} ls [<glob>]
    List <glob> matching or all topics.

  #{NAME} print [-t|--topic <topic>] [<pattern>]
  #{NAME} print [-t|--topic <topic>] [--time <time>] [<pattern>]
  #{NAME} print [-t|--topic <topic>] [--after <time>] [--before <time>] [<pattern>]
    Find all entries of a <topic> matching given <pattern>.
    The <pattern> can be a simple sub-string or a regular expression when
    enclosed in slashes ('/').
    A time or time range can be specified with this formatting:
      '4:20'             today at 4:20h
      'may 06'           May 6th this year
      'may 06 14:30'     May 6th this year at 14:30h
      '2022'             year 2022
      '2022/3'           March 2022
      '2022/3/14'        March 14th of year 2022
      '2022-03-14 14:30' March 14th of year 2022 at 14:30h

  #{NAME} help
    Print this help.

  #{NAME} -v|--version
    Print version information.
HELP

pex("#{NAME} v#{VERSION}") if %w[-v --version].include?(ARGV[0])

def root = mkdir_p(File.expand_path(ENV['LB_DIR'] || "~/.#{NAME}"))
def die!(msg, code: 1) = pex("#{NAME}: #{msg}", code:, out: $stderr)
def cmd?(name) = (ARGV[0] == name) && ARGV.shift

def mkdir_p(path)
  stack = []
  until File.directory?(path)
    stack << path
    path = File.dirname(path)
  end
  stack.reverse_each do |name|
    Dir.mkdir(name)
  rescue SystemCallError
    File.directory?(name) or die("unable to create path - #{name}", code: 3)
  end
  path
end

def file?(fname)
  stat = File.stat(fname) and (stat.file? && stat.readable?)
rescue SystemCallError
  false
end

if cmd?('ls')
  Dir.glob(File.join(root, "#{ARGV[0] || '*'}.log"), sort: true) do |fname|
    puts(File.basename(fname, '.log')) if file?(fname)
  end
  exit
end

def find_topic
  i = ARGV.index('--topic') || ARGV.index('-t') or return 'default'
  ARGV.delete_at(i)
  ARGV.delete_at(i) || 'default'
end

fname = File.join(root, "#{find_topic}.log")
pex(fname) if cmd?('name')

def flags(fname, mode)
  return File::SYNC | File::BINARY | File::RDONLY if mode != :write
  flags = File::SYNC | File::BINARY | File::WRONLY
  File.exist?(fname) ? flags | File::APPEND : flags | File::CREAT | File::EXCL
end

def with_file(fname, mode)
  File.open(fname, flags(fname, mode)) do |file|
    file.flock(mode == :write ? File::LOCK_EX : File::LOCK_SH)
    yield(file)
  end
rescue SystemCallError
  die!("unable to #{mode} file - #{fname}", code: 3)
end

def write_msg(out, msg)
  out.puts("[#{Time.now.utc.strftime('%FT%T')}] #{msg.tr("\r\n", ' ')}")
end

unless cmd?('print')
  with_file(fname, :write) do |file|
    write_msg(file, ARGV.join(' ')) unless ARGV.empty?
    if ARGV.empty? || File.pipe?($stdin)
      $stdin.each_line(chomp: true) { |line| write_msg(file, line) }
    end
  end
  exit
end

file?(fname) ? $stdout.sync = true : exit

if ARGV.empty?
  with_file(fname, :read) { |file| IO.copy_stream(file, $stdout) }
  exit
end

def as_time(str, name)
  tm = Date._parse(str)
  tk = tm.keys.sort!
  return format('[%04d-%02d-', tm[:year], tm[:mon]) if tk == %i[mon year]
  if tk == %i[mday mon year]
    return format('[%04d-%02d-%02dT', tm[:year], tm[:mon], tm[:mday])
  end
  now = Time.now.utc
  if tk == %i[mday mon]
    return format('[%02d%02d-', tm[:mon], tm[:mday]) if tm[:mon] > 12
    return format('[%04d-%02d-%02dT', now.year, tm[:mon], tm[:mday])
  end
  Time.utc(
    tm[:year] || now.year,
    tm[:mon] || now.mon,
    tm[:mday] || now.mday,
    tm[:hour],
    tm[:min]
  ).strftime('[%FT%H:%M:')
rescue ArgumentError, TypeError
  die!("invalid time format for '#{name}' - #{str}")
end

def find_time(name)
  i = ARGV.index(name) or return
  ARGV.delete_at(i)
  as_time(ARGV.delete_at(i) || die!("argument missing - #{name}"), name)
end

require('date_core')
time = find_time('--time')
if time
  die!('invalid option - --before') if ARGV.include?('--before')
  die!('invalid option - --after') if ARGV.include?('--after')
else
  before = find_time('--before')
  after = find_time('--after')
end

matcher =
  begin
    str = ARGV.join(' ')
    if str.empty?
      Module.new { define_singleton_method(:match?) { |_| true } }
    elsif str.start_with?('/') && str.end_with?('/')
      Regexp.new(str.delete_prefix('/').delete_suffix!('/'), Regexp::IGNORECASE)
    else
      Module.new { define_singleton_method(:match?) { |l| l.index(str) } }
    end
  rescue RegexpError => e
    die!("invalid regular expression - #{e}")
  end

def show_matching_before(file, time, matcher)
  len = time.size
  file.each_line do |line|
    break if line[0, len] >= time
    print(line) if matcher.match?(line)
  end
end

with_file(fname, :read) do |file|
  if time
    len = time.size
    file.each_line do |line|
      tm = line[0, len]
      break if tm > time
      print(line) if tm == time && matcher.match?(line)
    end
  elsif after
    len = after.size
    if before
      file.each_line do |line|
        next if line[0, len] <= after
        exit if line[0, before.size] >= before
        print(line) if matcher.match?(line)
        break
      end
      show_matching_before(file, before, matcher)
    else
      file.each_line do |line|
        next if after <= line[0, len]
        print(line) if matcher.match?(line)
      end
    end
  elsif before
    show_matching_before(file, before, matcher)
  else
    file.each_line { |line| print(line) if matcher.match?(line) }
  end
end
